# Crusst V1.1: Pure Rust Adaptive Kernel

**Date:** 2026-02-26
**Status:** Approved
**Branch:** v1.1 (from v0.0 baseline)
**Goal:** Infinite-resolution watertight geometry kernel with smart STEP export and trivial voxelization

## Constraints

- Pure Rust (no C/C++ bindings)
- Mission-critical dimensional accuracy
- Minimal dependencies (nalgebra + rayon only at runtime)
- Watertight manifold meshes by construction
- STEP export with exact BRep where possible
- Easily voxelizable for density/flow simulation
- Declarative composition API

## Architecture Overview

```
┌─────────────────────────────────────────────────────┐
│  Declarative Builder API (Shape)                    │
│  Shape::cylinder(5, 20).union(box3(10, 2, 15))     │
│         .subtract(cylinder(3, 25)).fillet(1.5)      │
└────────────────────┬────────────────────────────────┘
                     │ constructs
          ┌──────────▼──────────┐
          │  SdfNode Expression │
          │  DAG (Arc-shared)   │
          └──┬──────┬──────┬───┘
             │      │      │
     ┌───────▼┐ ┌───▼───┐ ┌▼─────────┐
     │Evaluate│ │Interval│ │ Gradient  │
     │ f(p)   │ │ [a, b] │ │ ∇f(p)    │
     └───┬────┘ └───┬───┘ └────┬─────┘
         │          │          │
    ┌────▼──────────▼──────────▼────┐
    │  Adaptive Octree              │
    │  (interval prunes empty cells)│
    └────────────┬──────────────────┘
                 │
    ┌────────────▼──────────────────┐
    │  Dual Contouring + QEF        │
    │  (sharp edges, watertight)    │
    └────────────┬──────────────────┘
                 │
    ┌────────────▼──────────────────┐
    │  TriangleMesh                 │
    │  (manifold, crack-free)       │
    └──┬─────────┬──────────┬──────┘
       │         │          │
   ┌───▼──┐  ┌──▼───┐  ┌───▼──────┐
   │ OBJ  │  │ STL  │  │Smart STEP│
   └──────┘  └──────┘  └──────────┘
```

## 1. Adaptive Octree + Dual Contouring Mesher

Replaces the `isosurface` crate (alpha quality marching cubes) with a pure-Rust
adaptive meshing pipeline. Zero external meshing dependencies.

### Stage 1: Adaptive Octree

- Root cell covers the shape's bounding box
- Recursive subdivision: split cells that straddle the surface (sign change at any corner pair)
- Prune cells where interval arithmetic proves the SDF is entirely positive or negative
- Max depth parameter controls resolution: depth N ~ equivalent to 2^N uniform grid
  - depth 8 = 256³ effective, depth 10 = 1024³, depth 12 = 4096³
- Memory scales with surface area O(N²), not volume O(N³)

### Stage 2: Edge Crossing Detection

- For each leaf cell with sign changes, find zero-crossings along cell edges
- Bisection refinement to locate crossing points to floating-point precision
- Compute SDF gradient at each crossing (analytical via DAG, or central differences for closures)

### Stage 3: QEF Vertex Placement

- For each cell with crossings, solve a Quadratic Error Function:
  minimize Σ (nᵢ · (v - pᵢ))² where pᵢ are crossing points and nᵢ are gradients
- This is a 3×3 least-squares solve (SVD)
- Preserves sharp edges and corners that marching cubes destroys
- Clamp vertex to cell bounds to prevent vertex drift

### Stage 4: Dual Contouring Face Generation

- For each edge shared by adjacent cells with a sign change, connect the QEF vertices
  of the surrounding cells to form a quad (split into 2 triangles)
- Produces manifold mesh: every edge has exactly 2 adjacent faces
- Watertight by construction

### Stage 5: Crack-Free Adaptive Transitions

- When adjacent cells differ in octree depth, the larger cell face must be subdivided
  to match the smaller cells' vertices
- T-junction elimination prevents cracks at resolution boundaries
- Implementation: check neighbor depth during face generation, insert bridge triangles

### Resolution Model

```rust
pub struct MeshSettings {
    pub max_depth: u8,        // Octree depth (8 = 256³ equivalent)
    pub min_depth: u8,        // Minimum refinement everywhere (default: 4)
    pub edge_tolerance: f64,  // Bisection convergence threshold
}
```

## 2. SdfNode Expression DAG

All built-in shapes construct an expression DAG enabling optimization and introspection.

### Node Types

```
SdfNode
├─ Primitives: Sphere, Box3, Cylinder, CappedCone, Torus, RoundedBox,
│              Capsule, Ellipsoid, RoundedCylinder, HalfSpace
├─ CSG: Union, Intersection, Difference, SmoothUnion, SmoothIntersection,
│       SmoothDifference
├─ Transforms: Translate, Rotate, Scale, Mirror, Shell, Round
├─ 2D→3D: Revolve(SdfNode2d), Extrude(SdfNode2d, f64)
└─ Opaque: Custom(Arc<dyn Sdf>)  — user closures, no introspection
```

### Three Evaluation Modes

1. **Point evaluation**: `evaluate(node, point) -> f64`
   Walk the DAG, evaluate the SDF at a single point.

2. **Interval evaluation**: `interval_evaluate(node, bbox) -> [f64, f64]`
   Compute conservative bounds on the SDF over a bounding box.
   Used by the octree to prune cells without evaluating corners.
   - Sphere: interval of |p - center| - radius over the bbox
   - Union: [min(a_lo, b_lo), min(a_hi, b_hi)]
   - Translate: evaluate inner with shifted bbox
   - Custom: falls back to [-∞, +∞] (no pruning)

3. **Gradient evaluation**: `gradient(node, point) -> Vector3<f64>`
   Analytical gradient via chain rule through the DAG.
   - Sphere: (point - center).normalize()
   - Union: gradient of whichever child is closer
   - Translate: gradient of inner (unchanged)
   - Custom: central differences fallback

### Backwards Compatibility

The `Sdf` trait remains the public API. All existing code works unchanged.
Built-in shapes implement both `Sdf` (for direct evaluation) and construct
an `SdfNode` (for optimization). The `Custom` variant wraps user-defined
closures with no loss of functionality (just no interval/gradient benefits).

## 3. Smart STEP Exporter

Three-tier strategy based on DAG analysis:

### Tier 1: Exact BRep (ships in V1.1)

For DAGs containing only recognized primitives + rigid transforms:
- Sphere → SPHERICAL_SURFACE entity
- Box3 → 6 PLANE faces
- Cylinder → CYLINDRICAL_SURFACE + 2 PLANE caps
- CappedCone → CONICAL_SURFACE + caps
- Torus → TOROIDAL_SURFACE
- Transforms adjust surface parameters (centers, orientations)

### Tier 2: Reconstructed BRep (deferred)

For booleans on analytical primitives (e.g., box with cylindrical hole):
- Compute surface-surface intersection curves analytically
- Build trimmed faces with exact pcurves
- Assemble CLOSED_SHELL with shared topology

### Tier 3: Tessellated Fallback (ships in V1.1)

For complex/smooth shapes:
- Extract mesh via adaptive dual contouring
- Write as TESSELLATED_SHELL_REPRESENTATION (AP242)
- High-quality mesh from the new mesher (much better than V1 triangulation)

### DAG Walker

```
fn export_strategy(node: &SdfNode) -> ExportTier {
    match node {
        primitive nodes → Tier1,
        boolean(a, b) if both Tier1 → Tier2 (or Tier3 until implemented),
        transform(inner) → inherit inner's tier,
        _ → Tier3
    }
}
```

## 4. Declarative Builder API

Rhino-inspired chaining API:

```rust
pub struct Shape {
    node: Arc<SdfNode>,
}

impl Shape {
    // Primitives
    pub fn sphere(radius: f64) -> Self;
    pub fn box3(hx: f64, hy: f64, hz: f64) -> Self;
    pub fn cylinder(radius: f64, height: f64) -> Self;
    pub fn torus(major: f64, minor: f64) -> Self;
    // ... all primitives

    // CSG (consumes self, returns new Shape)
    pub fn union(self, other: Shape) -> Self;
    pub fn subtract(self, other: Shape) -> Self;
    pub fn intersect(self, other: Shape) -> Self;
    pub fn fillet(self, radius: f64) -> Self;  // smooth union wrapper

    // Transforms
    pub fn translate(self, x: f64, y: f64, z: f64) -> Self;
    pub fn rotate_x(self, angle: f64) -> Self;
    pub fn rotate_y(self, angle: f64) -> Self;
    pub fn rotate_z(self, angle: f64) -> Self;
    pub fn scale(self, factor: f64) -> Self;
    pub fn mirror_x(self) -> Self;
    pub fn shell(self, thickness: f64) -> Self;

    // Export
    pub fn mesh(&self, settings: MeshSettings) -> TriangleMesh;
    pub fn export_obj(&self, path: &str) -> Result<()>;
    pub fn export_stl(&self, path: &str) -> Result<()>;
    pub fn export_step(&self, path: &str) -> Result<()>;

    // Simulation
    pub fn voxelize(&self, voxel_size_mm: f64) -> VoxelGrid;
    pub fn contains(&self, point: Vector3<f64>) -> bool;
    pub fn distance(&self, point: Vector3<f64>) -> f64;
}
```

Shapes are immutable and cheaply cloneable (Arc reference counting on the DAG).

## 5. Voxelization

```rust
pub struct VoxelGrid {
    pub resolution: [usize; 3],
    pub voxel_size: f64,
    pub origin: Vector3<f64>,
    pub data: Vec<f32>,  // SDF value at each voxel center
}
```

Evaluation is embarrassingly parallel (rayon). Each voxel independently evaluates
`shape.distance(voxel_center)`. The sign determines inside/outside; the magnitude
gives distance to surface.

Feeds into: density simulation, flow simulation, thermal analysis, topology optimization.

## 6. Dependencies

### V1.1 Runtime
- `nalgebra` — vector math, matrix operations, rotations, SVD (for QEF)
- `rayon` — parallel octree evaluation and voxelization

### Removed
- `isosurface` — replaced by our adaptive mesher
- `tiny_http` — moved to dev-dependency (viewer binary)

### Dev-only
- `approx` — test assertions
- `tiny_http` — viewer server binary

## 7. V1.1 Scope

| Component | Ships | Deferred |
|-----------|-------|----------|
| Adaptive octree | Yes | — |
| Dual contouring + QEF | Yes | — |
| Crack-free transitions | Yes | — |
| SdfNode DAG | Yes (all types) | WGSL codegen, tape optimization |
| Interval arithmetic | Yes (all built-ins) | Custom closure intervals |
| Analytical gradients | Yes (all built-ins) | — |
| Smart STEP Tier 1 | Yes (exact primitives) | — |
| Smart STEP Tier 2 | — | Reconstructed booleans |
| Smart STEP Tier 3 | Yes (tessellated) | — |
| Builder API | Yes | — |
| Voxelization | Yes (CPU, rayon) | GPU voxelization |
| OBJ/STL export | Yes (wired to new mesher) | glTF, 3MF, PLY |
| Test suite | All V1 pass + new quality tests | Criterion benchmarks |

## 8. Git Branching

1. Tag current main as `v0.0`
2. Rename current main branch to `v0.0`
3. Create `v1.1` branch from `v0.0`
4. All V2 work on `v1.1`
5. When complete, `main` mirrors `v1.1`

## Decision Log

| Decision | Rationale |
|----------|-----------|
| Path A (SDF + Smart STEP) over BRep or Hybrid | SDF gives reliable booleans, trivial voxelization, declarative composition. BRep adds multi-decade complexity for STEP that Tier 1 + 3 covers 80% of. |
| Adaptive dual contouring over marching cubes | Sharp feature preservation, resolution scales with surface area not volume, watertight by construction |
| QEF vertex placement | Optimal position for sharp edges/corners, small 3×3 SVD solve |
| Expression DAG over pure trait dispatch | Enables interval arithmetic (10-100x pruning), analytical gradients, smart STEP introspection |
| nalgebra SVD for QEF | Already a dependency, provides the linear algebra needed |
| Tiered STEP export | Exact where possible, tessellated fallback for complex. Avoids NURBS fitting complexity. |
| Builder API with Arc<SdfNode> | Immutable, cheaply cloneable, thread-safe, composable |
