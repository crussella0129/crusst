# Crusst V1.1 Adaptive Kernel Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the isosurface crate with a pure-Rust adaptive dual contouring mesher, add an SdfNode expression DAG with interval arithmetic and analytical gradients, a declarative Shape builder API, voxelization, and smart tiered STEP export.

**Architecture:** SDF expression DAG as the source of truth. Adaptive octree subdivides only near the surface. Dual contouring with QEF vertex placement produces watertight manifold meshes. Smart STEP exporter walks the DAG to emit exact BRep for recognized primitives, tessellated fallback for complex shapes.

**Tech Stack:** Rust, nalgebra (math + SVD for QEF), rayon (parallel evaluation)

**Branch:** `v1.1` (branched from `v0.0`)

**Key files reference:**
- `src/mesh.rs` — current mesher (isosurface crate, 166 lines) — will be REPLACED
- `src/shape.rs` — current Sdf trait + all shape structs (583 lines) — will be EXTENDED
- `src/primitives.rs` — SDF functions (162 lines) — unchanged
- `src/csg.rs` — CSG operations (48 lines) — unchanged
- `src/lib.rs` — module declarations — will add new modules
- `src/step_export.rs` — current per-triangle STEP — will be REPLACED
- `Cargo.toml` — will remove isosurface, move tiny_http to dev-deps

---

## Task 1: Dependency cleanup — remove isosurface, restructure Cargo.toml

**Files:**
- Modify: `Cargo.toml`
- Modify: `src/mesh.rs` (extract `TriangleMesh` struct, gut the rest)
- Create: `src/types.rs` (shared types: `TriangleMesh`, `MeshSettings`, `Interval`, `BBox3`)
- Modify: `src/lib.rs`

**Step 1: Create `src/types.rs` with shared data types**

Move `TriangleMesh` and `to_binary()` from `src/mesh.rs` into `src/types.rs`.
Add the new types that the whole codebase will use:

```rust
// src/types.rs
use nalgebra::Vector3;

/// A triangle mesh extracted from a signed distance field.
pub struct TriangleMesh {
    pub vertices: Vec<Vector3<f64>>,
    pub normals: Vec<Vector3<f64>>,
    pub indices: Vec<u32>,
}

impl TriangleMesh {
    pub fn to_binary(&self) -> Vec<u8> { /* keep existing impl */ }
}

/// Axis-aligned bounding box.
#[derive(Clone, Copy, Debug)]
pub struct BBox3 {
    pub min: Vector3<f64>,
    pub max: Vector3<f64>,
}

impl BBox3 {
    pub fn new(min: Vector3<f64>, max: Vector3<f64>) -> Self { Self { min, max } }
    pub fn center(&self) -> Vector3<f64> { (self.min + self.max) * 0.5 }
    pub fn size(&self) -> Vector3<f64> { self.max - self.min }
    pub fn contains(&self, p: Vector3<f64>) -> bool {
        p.x >= self.min.x && p.x <= self.max.x &&
        p.y >= self.min.y && p.y <= self.max.y &&
        p.z >= self.min.z && p.z <= self.max.z
    }
    /// Split into 8 octants.
    pub fn octants(&self) -> [BBox3; 8] {
        let c = self.center();
        let mn = self.min;
        let mx = self.max;
        [
            BBox3::new(Vector3::new(mn.x, mn.y, mn.z), Vector3::new(c.x, c.y, c.z)),
            BBox3::new(Vector3::new(c.x, mn.y, mn.z), Vector3::new(mx.x, c.y, c.z)),
            BBox3::new(Vector3::new(mn.x, c.y, mn.z), Vector3::new(c.x, mx.y, c.z)),
            BBox3::new(Vector3::new(c.x, c.y, mn.z), Vector3::new(mx.x, mx.y, c.z)),
            BBox3::new(Vector3::new(mn.x, mn.y, c.z), Vector3::new(c.x, c.y, mx.z)),
            BBox3::new(Vector3::new(c.x, mn.y, c.z), Vector3::new(mx.x, c.y, mx.z)),
            BBox3::new(Vector3::new(mn.x, c.y, c.z), Vector3::new(c.x, mx.y, mx.z)),
            BBox3::new(Vector3::new(c.x, c.y, c.z), Vector3::new(mx.x, mx.y, mx.z)),
        ]
    }
}

/// Closed interval [lo, hi] for interval arithmetic.
#[derive(Clone, Copy, Debug)]
pub struct Interval {
    pub lo: f64,
    pub hi: f64,
}

impl Interval {
    pub fn new(lo: f64, hi: f64) -> Self { Self { lo, hi } }
    pub fn entire() -> Self { Self { lo: f64::NEG_INFINITY, hi: f64::INFINITY } }
    pub fn definitely_positive(&self) -> bool { self.lo > 0.0 }
    pub fn definitely_negative(&self) -> bool { self.hi < 0.0 }
}

/// Settings controlling adaptive mesh extraction.
pub struct MeshSettings {
    pub max_depth: u8,
    pub min_depth: u8,
    pub edge_tolerance: f64,
}

impl Default for MeshSettings {
    fn default() -> Self {
        Self { max_depth: 8, min_depth: 3, edge_tolerance: 1e-6 }
    }
}
```

**Step 2: Update `Cargo.toml`**

Remove `isosurface` from `[dependencies]`. Move `tiny_http` to `[dev-dependencies]`.

```toml
[dependencies]
nalgebra = "0.33"
rayon = "1.10"

[dev-dependencies]
approx = "0.5"
tiny_http = "0.12"
```

**Step 3: Update `src/lib.rs`**

Add `pub mod types;` and ensure other modules use `crate::types::TriangleMesh` instead of `crate::mesh::TriangleMesh`.

**Step 4: Gut `src/mesh.rs`**

Remove all isosurface crate usage. Keep the module but make it re-export from types and contain only a stub `extract_mesh` that will be filled in Task 4. For now, have it panic with `todo!()` so the code compiles but makes it clear the mesher is being replaced.

Temporarily keep the old `extract_mesh` signature so that `src/bin/viewer.rs`, `src/export.rs`, `src/obj_export.rs`, and `tests/showcase_test.rs` still compile.

**Step 5: Run `cargo check` to verify compilation**

Run: `cargo check 2>&1`
Expected: Compiles with no errors (warnings OK)

**Step 6: Commit**

```bash
git add -A && git commit -m "refactor: remove isosurface dependency, add types module"
```

---

## Task 2: SdfNode expression DAG — point evaluation

**Files:**
- Create: `src/dag.rs` (the SdfNode enum + point evaluation)
- Modify: `src/lib.rs` (add `pub mod dag;`)

**Step 1: Write test for DAG point evaluation**

Create `tests/dag_test.rs`:

```rust
use crusst::dag::{SdfNode, SdfNode2d};
use nalgebra::Vector3;
use std::sync::Arc;

#[test]
fn dag_sphere_at_center_is_negative() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 10.0 };
    assert!((node.evaluate(Vector3::zeros()) - (-10.0)).abs() < 1e-10);
}

#[test]
fn dag_sphere_on_surface_is_zero() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 10.0 };
    assert!(node.evaluate(Vector3::new(10.0, 0.0, 0.0)).abs() < 1e-10);
}

#[test]
fn dag_union_is_min() {
    let a = Arc::new(SdfNode::Sphere { center: Vector3::new(-5.0, 0.0, 0.0), radius: 3.0 });
    let b = Arc::new(SdfNode::Sphere { center: Vector3::new(5.0, 0.0, 0.0), radius: 3.0 });
    let u = SdfNode::Union(a, b);
    // Point at origin: equidistant from both spheres
    let d = u.evaluate(Vector3::zeros());
    assert!((d - 2.0).abs() < 1e-10); // dist to each sphere = 5 - 3 = 2
}

#[test]
fn dag_translate_moves_shape() {
    let s = Arc::new(SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 });
    let t = SdfNode::Translate(s, Vector3::new(10.0, 0.0, 0.0));
    // Center of translated sphere should be at (10,0,0)
    assert!((t.evaluate(Vector3::new(10.0, 0.0, 0.0)) - (-5.0)).abs() < 1e-10);
}

#[test]
fn dag_difference_subtracts() {
    let a = Arc::new(SdfNode::Box3 {
        center: Vector3::zeros(), half_extents: Vector3::new(10.0, 10.0, 10.0)
    });
    let b = Arc::new(SdfNode::Sphere { center: Vector3::zeros(), radius: 7.0 });
    let diff = SdfNode::Difference(a, b);
    // Origin is inside box but inside sphere → outside difference
    assert!(diff.evaluate(Vector3::zeros()) > 0.0);
    // Corner of box (far from sphere) → inside difference
    assert!(diff.evaluate(Vector3::new(9.0, 9.0, 0.0)) < 0.0);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --test dag_test 2>&1`
Expected: FAIL — module `dag` not found

**Step 3: Implement `src/dag.rs`**

Define the `SdfNode` enum with all primitive, CSG, transform, and 2D→3D variants.
Implement `evaluate(&self, point: Vector3<f64>) -> f64` by delegating to the existing
functions in `primitives.rs` and `csg.rs`.

Key variants:
- All 10 primitives: Sphere, Box3, Cylinder, CappedCone, Torus, RoundedBox, Capsule, Ellipsoid, RoundedCylinder, HalfSpace
- 6 CSG: Union, Intersection, Difference, SmoothUnion, SmoothIntersection, SmoothDifference
- 6 transforms: Translate, Rotate, Scale, Mirror, Shell, Round
- 2D→3D: Revolve, Extrude (with SdfNode2d sub-enum)
- Opaque: `Custom(Arc<dyn crate::shape::Sdf>)` for user closures

Each variant stores `Arc<SdfNode>` children for CSG/transforms (cheap clone, shared ownership).

Also define `SdfNode2d` enum: Circle2d, Rect2d, Union2d, Difference2d, Custom2d.

**Step 4: Add `pub mod dag;` to `src/lib.rs`**

**Step 5: Run tests**

Run: `cargo test --test dag_test 2>&1`
Expected: All 5 tests PASS

**Step 6: Commit**

```bash
git add -A && git commit -m "feat: SdfNode expression DAG with point evaluation"
```

---

## Task 3: Interval arithmetic on the DAG

**Files:**
- Modify: `src/dag.rs` (add `interval_evaluate` method)
- Modify: `src/types.rs` (add interval arithmetic operations)

**Step 1: Write tests for interval evaluation**

Add to `tests/dag_test.rs`:

```rust
use crusst::types::{BBox3, Interval};

#[test]
fn interval_sphere_far_away_is_positive() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::new(20.0, 20.0, 20.0), Vector3::new(25.0, 25.0, 25.0));
    let iv = node.interval_evaluate(&bbox);
    assert!(iv.definitely_positive());
}

#[test]
fn interval_sphere_containing_box_is_negative() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 100.0 };
    let bbox = BBox3::new(Vector3::new(-1.0, -1.0, -1.0), Vector3::new(1.0, 1.0, 1.0));
    let iv = node.interval_evaluate(&bbox);
    assert!(iv.definitely_negative());
}

#[test]
fn interval_sphere_straddling_surface_is_neither() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::new(3.0, -1.0, -1.0), Vector3::new(7.0, 1.0, 1.0));
    let iv = node.interval_evaluate(&bbox);
    assert!(!iv.definitely_positive());
    assert!(!iv.definitely_negative());
}

#[test]
fn interval_union_prunes_correctly() {
    let a = Arc::new(SdfNode::Sphere { center: Vector3::new(-20.0, 0.0, 0.0), radius: 5.0 });
    let b = Arc::new(SdfNode::Sphere { center: Vector3::new(20.0, 0.0, 0.0), radius: 5.0 });
    let u = SdfNode::Union(a, b);
    // Box near sphere A: union should NOT be definitely positive
    let bbox = BBox3::new(Vector3::new(-22.0, -1.0, -1.0), Vector3::new(-18.0, 1.0, 1.0));
    let iv = u.interval_evaluate(&bbox);
    assert!(!iv.definitely_positive());
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --test dag_test interval 2>&1`
Expected: FAIL — no method `interval_evaluate`

**Step 3: Implement interval arithmetic**

Add to `src/types.rs`: basic `Interval` operations (add, sub, mul, min, max, abs, sqrt, norm_interval).

Add to `src/dag.rs`:
```rust
impl SdfNode {
    pub fn interval_evaluate(&self, bbox: &BBox3) -> Interval { ... }
}
```

For each primitive, compute the conservative interval of the SDF over the bbox:
- Sphere: interval of `|p - center|` over bbox minus radius
- Box3: interval of box SDF over bbox (per-axis intervals)
- Union(a, b): `Interval::new(a_iv.lo.min(b_iv.lo), a_iv.hi.min(b_iv.hi))`
- Translate(inner, offset): evaluate inner with shifted bbox
- Custom: return `Interval::entire()` (no pruning possible)

**Step 4: Run tests**

Run: `cargo test --test dag_test interval 2>&1`
Expected: All 4 interval tests PASS

**Step 5: Commit**

```bash
git add -A && git commit -m "feat: interval arithmetic for octree pruning"
```

---

## Task 4: Analytical gradient computation

**Files:**
- Modify: `src/dag.rs` (add `gradient` method)

**Step 1: Write tests for gradient evaluation**

Add to `tests/dag_test.rs`:

```rust
#[test]
fn gradient_sphere_points_outward() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let g = node.gradient(Vector3::new(5.0, 0.0, 0.0));
    // On +X surface, gradient should point in +X direction
    assert!((g.x - 1.0).abs() < 1e-6);
    assert!(g.y.abs() < 1e-6);
    assert!(g.z.abs() < 1e-6);
}

#[test]
fn gradient_sphere_is_unit_length() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let g = node.gradient(Vector3::new(3.0, 4.0, 0.0));
    assert!((g.norm() - 1.0).abs() < 1e-6);
}

#[test]
fn gradient_box_on_face_is_normal() {
    let node = SdfNode::Box3 {
        center: Vector3::zeros(),
        half_extents: Vector3::new(5.0, 5.0, 5.0),
    };
    // On +X face (not near edge)
    let g = node.gradient(Vector3::new(5.0, 0.0, 0.0));
    assert!((g.x - 1.0).abs() < 1e-4);
}

#[test]
fn gradient_translate_unchanged() {
    let s = Arc::new(SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 });
    let t = SdfNode::Translate(s, Vector3::new(10.0, 0.0, 0.0));
    let g = t.gradient(Vector3::new(15.0, 0.0, 0.0));
    assert!((g.x - 1.0).abs() < 1e-6);
}
```

**Step 2: Run test to verify failure, then implement**

Implement `gradient(&self, point: Vector3<f64>) -> Vector3<f64>` on `SdfNode`.
For each primitive, compute the analytical gradient:
- Sphere: `(point - center).normalize()`
- Box3: gradient of the box SDF (per-axis, sign depends on which face is closest)
- Union(a, b): gradient of whichever child has the smaller value
- Translate(inner, offset): `inner.gradient(point - offset)`
- Scale(inner, factor): gradient of inner evaluated at `point / factor`
- Custom: fallback to central differences `(f(p+ε) - f(p-ε)) / 2ε` per axis

**Step 3: Run all tests**

Run: `cargo test --test dag_test 2>&1`
Expected: All tests PASS (point eval + interval + gradient)

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: analytical gradient computation on DAG"
```

---

## Task 5: Adaptive octree construction

**Files:**
- Create: `src/octree.rs`
- Modify: `src/lib.rs` (add `pub mod octree;`)

**Step 1: Write tests**

Create `tests/octree_test.rs`:

```rust
use crusst::dag::SdfNode;
use crusst::octree::Octree;
use crusst::types::{BBox3, MeshSettings};
use nalgebra::Vector3;

#[test]
fn octree_sphere_has_leaf_cells() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let settings = MeshSettings { max_depth: 4, min_depth: 2, edge_tolerance: 1e-6 };
    let tree = Octree::build(&node, &bbox, &settings);
    assert!(tree.leaf_count() > 0);
}

#[test]
fn octree_empty_region_has_no_surface_cells() {
    let node = SdfNode::Sphere { center: Vector3::new(100.0, 0.0, 0.0), radius: 1.0 };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let settings = MeshSettings { max_depth: 6, min_depth: 2, edge_tolerance: 1e-6 };
    let tree = Octree::build(&node, &bbox, &settings);
    // All cells should be pruned (entirely outside)
    assert_eq!(tree.surface_cell_count(), 0);
}

#[test]
fn octree_deeper_produces_more_cells() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let s4 = MeshSettings { max_depth: 4, min_depth: 2, edge_tolerance: 1e-6 };
    let s6 = MeshSettings { max_depth: 6, min_depth: 2, edge_tolerance: 1e-6 };
    let t4 = Octree::build(&node, &bbox, &s4);
    let t6 = Octree::build(&node, &bbox, &s6);
    assert!(t6.surface_cell_count() > t4.surface_cell_count());
}
```

**Step 2: Implement `src/octree.rs`**

Data structures:
```rust
pub struct OctreeCell {
    pub bbox: BBox3,
    pub depth: u8,
    pub corners: [f64; 8],        // SDF values at 8 corners
    pub children: Option<Box<[OctreeCell; 8]>>,
}

pub struct Octree {
    pub root: OctreeCell,
}
```

`Octree::build(node, bbox, settings)`:
1. Evaluate SDF at 8 corners of root cell
2. If `interval_evaluate` proves entirely inside or outside AND depth >= min_depth → leaf (no surface)
3. If sign changes exist among corners AND depth < max_depth → subdivide into 8 children, recurse
4. If depth >= max_depth → leaf (surface cell)
5. If no sign changes AND depth >= min_depth → leaf (no surface)

Helper methods:
- `leaf_count()` — count all leaf cells
- `surface_cell_count()` — count leaf cells with sign changes
- `surface_cells()` — iterate over leaf cells with sign changes (used by dual contouring)

**Step 3: Run tests**

Run: `cargo test --test octree_test 2>&1`
Expected: All 3 tests PASS

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: adaptive octree with interval arithmetic pruning"
```

---

## Task 6: QEF solver

**Files:**
- Create: `src/qef.rs`
- Modify: `src/lib.rs` (add `pub mod qef;`)

**Step 1: Write tests**

Create `tests/qef_test.rs`:

```rust
use crusst::qef::solve_qef;
use crusst::types::BBox3;
use nalgebra::Vector3;

#[test]
fn qef_single_plane_intersection() {
    // One crossing at (5, 0, 0) with normal (1, 0, 0)
    // QEF solution should be at (5, 0, 0)
    let positions = vec![Vector3::new(5.0, 0.0, 0.0)];
    let normals = vec![Vector3::new(1.0, 0.0, 0.0)];
    let bounds = BBox3::new(Vector3::new(0.0, -5.0, -5.0), Vector3::new(10.0, 5.0, 5.0));
    let v = solve_qef(&positions, &normals, &bounds);
    assert!((v.x - 5.0).abs() < 1e-4);
}

#[test]
fn qef_two_perpendicular_planes() {
    // Edge: crossing at (5, 0, z) with normal (1,0,0) and (0, 0, z) at normal (0,0,1)
    // QEF should place vertex near the edge intersection
    let positions = vec![
        Vector3::new(5.0, 0.0, 0.0),
        Vector3::new(0.0, 0.0, 5.0),
    ];
    let normals = vec![
        Vector3::new(1.0, 0.0, 0.0),
        Vector3::new(0.0, 0.0, 1.0),
    ];
    let bounds = BBox3::new(Vector3::new(0.0, -5.0, 0.0), Vector3::new(10.0, 5.0, 10.0));
    let v = solve_qef(&positions, &normals, &bounds);
    assert!((v.x - 5.0).abs() < 1e-2);
    assert!((v.z - 5.0).abs() < 1e-2);
}

#[test]
fn qef_vertex_clamped_to_bounds() {
    // Adversarial case: normals that would pull vertex far outside bounds
    let positions = vec![Vector3::new(1.0, 0.0, 0.0)];
    let normals = vec![Vector3::new(0.0, 1.0, 0.0)]; // perpendicular to crossing — degenerate
    let bounds = BBox3::new(Vector3::zeros(), Vector3::new(2.0, 2.0, 2.0));
    let v = solve_qef(&positions, &normals, &bounds);
    assert!(bounds.contains(v));
}
```

**Step 2: Implement `src/qef.rs`**

```rust
use nalgebra::{Vector3, Matrix3, Vector3 as Vec3};
use crate::types::BBox3;

/// Solve the Quadratic Error Function: find the point v that minimizes
/// Σ (nᵢ · (v - pᵢ))²
/// where pᵢ are edge crossing positions and nᵢ are surface normals.
///
/// Uses nalgebra's SVD to solve the 3×3 least-squares system.
/// Result is clamped to the cell bounds to prevent vertex drift.
pub fn solve_qef(
    positions: &[Vector3<f64>],
    normals: &[Vector3<f64>],
    bounds: &BBox3,
) -> Vector3<f64> { ... }
```

Algorithm:
1. Build ATA (3×3 matrix) and ATb (3-vector) from the normal equations:
   - For each crossing i: ATA += nᵢ * nᵢᵀ, ATb += nᵢ * (nᵢ · pᵢ)
2. Add mass point regularization: small weight toward center of crossings (prevents degeneracy)
3. Solve via SVD: v = ATA⁻¹ * ATb (using nalgebra's `SVD::solve`)
4. Clamp v to bounds

**Step 3: Run tests**

Run: `cargo test --test qef_test 2>&1`
Expected: All 3 tests PASS

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: QEF solver for dual contouring vertex placement"
```

---

## Task 7: Dual contouring — edge crossings + face generation

**Files:**
- Create: `src/dual_contouring.rs`
- Modify: `src/mesh.rs` (wire new `extract_mesh` to dual contouring)
- Modify: `src/lib.rs`

**Step 1: Write tests**

Create `tests/dc_test.rs`:

```rust
use crusst::dag::SdfNode;
use crusst::mesh::extract_mesh_adaptive;
use crusst::types::{BBox3, MeshSettings};
use nalgebra::Vector3;

#[test]
fn dc_sphere_produces_manifold_mesh() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let settings = MeshSettings { max_depth: 5, min_depth: 3, edge_tolerance: 1e-6 };
    let mesh = extract_mesh_adaptive(&node, &bbox, &settings);
    assert!(mesh.vertices.len() > 10);
    assert!(mesh.indices.len() > 10);
    assert_eq!(mesh.indices.len() % 3, 0);
}

#[test]
fn dc_sphere_is_watertight() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let settings = MeshSettings { max_depth: 5, min_depth: 3, edge_tolerance: 1e-6 };
    let mesh = extract_mesh_adaptive(&node, &bbox, &settings);

    // Check: every edge appears exactly twice (manifold)
    use std::collections::HashMap;
    let mut edge_count: HashMap<(u32, u32), usize> = HashMap::new();
    for tri in mesh.indices.chunks(3) {
        for i in 0..3 {
            let a = tri[i];
            let b = tri[(i + 1) % 3];
            let key = (a.min(b), a.max(b));
            *edge_count.entry(key).or_insert(0) += 1;
        }
    }
    let manifold = edge_count.values().filter(|&&c| c == 2).count();
    let total = edge_count.len();
    let ratio = manifold as f64 / total as f64;
    assert!(ratio > 0.95, "Manifold ratio: {:.2}% ({}/{})", ratio * 100.0, manifold, total);
}

#[test]
fn dc_box_has_sharp_edges() {
    let node = SdfNode::Box3 {
        center: Vector3::zeros(),
        half_extents: Vector3::new(5.0, 5.0, 5.0),
    };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let settings = MeshSettings { max_depth: 6, min_depth: 3, edge_tolerance: 1e-6 };
    let mesh = extract_mesh_adaptive(&node, &bbox, &settings);

    // Check that some vertices are near the box corners (QEF should recover sharp features)
    let corner = Vector3::new(5.0, 5.0, 5.0);
    let min_dist = mesh.vertices.iter()
        .map(|v| (v - corner).norm())
        .fold(f64::INFINITY, f64::min);
    // With QEF, at least one vertex should be within cell_size of the corner
    let cell_size = 14.0 / 64.0; // bbox_size / 2^max_depth
    assert!(min_dist < cell_size * 2.0,
        "Nearest vertex to corner is {:.4}, expected < {:.4}", min_dist, cell_size * 2.0);
}

#[test]
fn dc_higher_depth_produces_more_triangles() {
    let node = SdfNode::Sphere { center: Vector3::zeros(), radius: 5.0 };
    let bbox = BBox3::new(Vector3::from_element(-7.0), Vector3::from_element(7.0));
    let s4 = MeshSettings { max_depth: 4, min_depth: 2, edge_tolerance: 1e-6 };
    let s6 = MeshSettings { max_depth: 6, min_depth: 2, edge_tolerance: 1e-6 };
    let m4 = extract_mesh_adaptive(&node, &bbox, &s4);
    let m6 = extract_mesh_adaptive(&node, &bbox, &s6);
    assert!(m6.indices.len() > m4.indices.len());
}
```

**Step 2: Implement `src/dual_contouring.rs`**

Main function:
```rust
pub fn extract_mesh_adaptive(
    node: &SdfNode,
    bbox: &BBox3,
    settings: &MeshSettings,
) -> TriangleMesh { ... }
```

Algorithm:
1. Build adaptive octree via `Octree::build(node, bbox, settings)`
2. For each surface leaf cell:
   a. Find edge crossings (bisection along edges with sign changes)
   b. Compute gradient at each crossing via `node.gradient(crossing_point)`
   c. Solve QEF to get vertex position
   d. Store vertex index in a HashMap keyed by cell identifier
3. For each edge in the octree shared by 2+ surface cells with sign change:
   a. Look up the QEF vertices of the adjacent cells
   b. If 2 cells: emit 2 triangles (a quad)
   c. If 4 cells (uniform case): emit 4 triangles
4. Compute per-vertex normals via `node.gradient(vertex_position)`
5. Return TriangleMesh

For adaptive transitions (cells at different depths sharing an edge): insert bridge
geometry to prevent T-junctions. This is the most complex part.

**Step 3: Update `src/mesh.rs`**

Add `extract_mesh_adaptive` as the primary mesher. Keep the old `extract_mesh` signature
as a compatibility wrapper that converts bbox_min/bbox_max/resolution to
BBox3/MeshSettings and calls the new function.

**Step 4: Run tests**

Run: `cargo test --test dc_test 2>&1`
Expected: All 4 tests PASS

Run: `cargo test 2>&1`
Expected: ALL existing tests still pass (including showcase tests via compatibility wrapper)

**Step 5: Commit**

```bash
git add -A && git commit -m "feat: adaptive dual contouring mesher with QEF"
```

---

## Task 8: Declarative Shape builder API

**Files:**
- Create: `src/builder.rs`
- Modify: `src/lib.rs` (add `pub mod builder;`)

**Step 1: Write tests**

Create `tests/builder_test.rs`:

```rust
use crusst::builder::Shape;
use crusst::types::MeshSettings;
use nalgebra::Vector3;

#[test]
fn builder_sphere_evaluates() {
    let s = Shape::sphere(5.0);
    assert!((s.distance(Vector3::zeros()) - (-5.0)).abs() < 1e-10);
}

#[test]
fn builder_chain_union() {
    let s = Shape::sphere(5.0)
        .union(Shape::sphere(5.0).translate(10.0, 0.0, 0.0));
    assert!(s.contains(Vector3::zeros()));
    assert!(s.contains(Vector3::new(10.0, 0.0, 0.0)));
    assert!(!s.contains(Vector3::new(100.0, 0.0, 0.0)));
}

#[test]
fn builder_subtract() {
    let s = Shape::box3(10.0, 10.0, 10.0)
        .subtract(Shape::sphere(7.0));
    // Origin: inside box but inside sphere → outside result
    assert!(!s.contains(Vector3::zeros()));
    // Corner: inside box, outside sphere → inside result
    assert!(s.contains(Vector3::new(9.0, 9.0, 0.0)));
}

#[test]
fn builder_mesh_produces_triangles() {
    let s = Shape::sphere(5.0);
    let mesh = s.mesh(MeshSettings { max_depth: 5, min_depth: 3, edge_tolerance: 1e-6 });
    assert!(mesh.indices.len() > 30);
}

#[test]
fn builder_clone_is_cheap() {
    let s = Shape::sphere(5.0).translate(1.0, 2.0, 3.0);
    let s2 = s.clone(); // Should be Arc clone, not deep copy
    assert!((s.distance(Vector3::zeros()) - s2.distance(Vector3::zeros())).abs() < 1e-15);
}
```

**Step 2: Implement `src/builder.rs`**

```rust
use std::sync::Arc;
use nalgebra::Vector3;
use crate::dag::SdfNode;
use crate::types::{TriangleMesh, MeshSettings, BBox3};
use crate::dual_contouring::extract_mesh_adaptive;

#[derive(Clone)]
pub struct Shape {
    node: Arc<SdfNode>,
}

impl Shape {
    // Primitives (centered at origin by default)
    pub fn sphere(radius: f64) -> Self { ... }
    pub fn box3(hx: f64, hy: f64, hz: f64) -> Self { ... }
    pub fn cylinder(radius: f64, height: f64) -> Self { ... }
    pub fn torus(major: f64, minor: f64) -> Self { ... }
    pub fn capsule(a: Vector3<f64>, b: Vector3<f64>, radius: f64) -> Self { ... }
    // ... all primitives

    // CSG
    pub fn union(self, other: Shape) -> Self { ... }
    pub fn subtract(self, other: Shape) -> Self { ... }
    pub fn intersect(self, other: Shape) -> Self { ... }
    pub fn smooth_union(self, other: Shape, k: f64) -> Self { ... }

    // Transforms
    pub fn translate(self, x: f64, y: f64, z: f64) -> Self { ... }
    pub fn rotate_x(self, angle: f64) -> Self { ... }
    pub fn rotate_y(self, angle: f64) -> Self { ... }
    pub fn rotate_z(self, angle: f64) -> Self { ... }
    pub fn scale(self, factor: f64) -> Self { ... }
    pub fn mirror_x(self) -> Self { ... }
    pub fn shell(self, thickness: f64) -> Self { ... }

    // Query
    pub fn distance(&self, point: Vector3<f64>) -> f64 { self.node.evaluate(point) }
    pub fn contains(&self, point: Vector3<f64>) -> bool { self.node.evaluate(point) < 0.0 }

    // Meshing
    pub fn bounding_box(&self) -> BBox3 { /* compute from DAG */ }
    pub fn mesh(&self, settings: MeshSettings) -> TriangleMesh {
        let bbox = self.bounding_box();
        extract_mesh_adaptive(&self.node, &bbox, &settings)
    }

    // Export (delegates to mesh + exporter)
    pub fn export_obj(&self, path: &str) -> std::io::Result<()> { ... }
    pub fn export_stl(&self, path: &str) -> std::io::Result<()> { ... }
}
```

Bounding box computation: walk the DAG and compute conservative bounds.
- Sphere: center ± radius
- Box3: center ± half_extents
- Union(a, b): merge bounding boxes
- Translate(inner, offset): inner bbox + offset
- Scale(inner, factor): scale inner bbox

**Step 3: Run tests**

Run: `cargo test --test builder_test 2>&1`
Expected: All 5 tests PASS

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: declarative Shape builder API"
```

---

## Task 9: Voxelization

**Files:**
- Create: `src/voxel.rs`
- Modify: `src/lib.rs`
- Modify: `src/builder.rs` (add `voxelize` method to Shape)

**Step 1: Write tests**

Create `tests/voxel_test.rs`:

```rust
use crusst::builder::Shape;
use crusst::voxel::VoxelGrid;
use nalgebra::Vector3;

#[test]
fn voxelize_sphere_center_is_negative() {
    let s = Shape::sphere(5.0);
    let grid = s.voxelize(1.0); // 1mm voxels
    // Center voxel should be negative (inside)
    let center_idx = grid.index_at(Vector3::zeros());
    assert!(grid.data[center_idx] < 0.0);
}

#[test]
fn voxelize_sphere_far_is_positive() {
    let s = Shape::sphere(5.0);
    let grid = s.voxelize(1.0);
    // Far corner should be positive (outside)
    let far = grid.index_at(Vector3::new(grid.origin.x, grid.origin.y, grid.origin.z));
    assert!(grid.data[far] > 0.0);
}

#[test]
fn voxelize_resolution_matches() {
    let s = Shape::sphere(5.0);
    let grid = s.voxelize(0.5);
    // Bounding box ~14 units wide, 0.5mm voxels → ~28 cells per axis
    assert!(grid.resolution[0] >= 20);
    assert!(grid.resolution[0] <= 40);
}
```

**Step 2: Implement `src/voxel.rs`**

```rust
use nalgebra::Vector3;
use rayon::prelude::*;

pub struct VoxelGrid {
    pub resolution: [usize; 3],
    pub voxel_size: f64,
    pub origin: Vector3<f64>,
    pub data: Vec<f32>,
}

impl VoxelGrid {
    pub fn index_at(&self, world: Vector3<f64>) -> usize { ... }
    pub fn world_at(&self, ix: usize, iy: usize, iz: usize) -> Vector3<f64> { ... }
}
```

Shape::voxelize:
1. Compute bounding box with padding (1 voxel margin)
2. Compute resolution from bbox size / voxel_size
3. Allocate data vec
4. Use rayon parallel iterator to evaluate SDF at each voxel center
5. Return VoxelGrid

**Step 3: Run tests**

Run: `cargo test --test voxel_test 2>&1`
Expected: All 3 tests PASS

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: parallel voxelization with rayon"
```

---

## Task 10: Smart STEP exporter (Tier 1 + Tier 3)

**Files:**
- Rewrite: `src/step_export.rs`
- Modify: `src/builder.rs` (add `export_step` method)

**Step 1: Write tests**

Add to `tests/builder_test.rs` or create `tests/step_test.rs`:

```rust
use crusst::builder::Shape;
use std::path::Path;

#[test]
fn step_export_sphere_contains_spherical_surface() {
    let s = Shape::sphere(10.0);
    let path = "target/tmp/test_sphere.step";
    std::fs::create_dir_all("target/tmp").unwrap();
    s.export_step(path).unwrap();
    let content = std::fs::read_to_string(path).unwrap();
    assert!(content.contains("SPHERICAL_SURFACE"));
    assert!(content.contains("CLOSED_SHELL"));
}

#[test]
fn step_export_box_contains_planes() {
    let s = Shape::box3(5.0, 3.0, 8.0);
    let path = "target/tmp/test_box.step";
    std::fs::create_dir_all("target/tmp").unwrap();
    s.export_step(path).unwrap();
    let content = std::fs::read_to_string(path).unwrap();
    assert!(content.contains("PLANE"));
    assert!(content.contains("CLOSED_SHELL"));
}

#[test]
fn step_export_smooth_union_uses_tessellated() {
    let s = Shape::sphere(5.0).smooth_union(Shape::sphere(5.0).translate(8.0, 0.0, 0.0), 2.0);
    let path = "target/tmp/test_smooth.step";
    std::fs::create_dir_all("target/tmp").unwrap();
    s.export_step(path).unwrap();
    let content = std::fs::read_to_string(path).unwrap();
    // Smooth union cannot be exact BRep → should fallback to tessellated
    assert!(content.contains("TRIANGULATED") || content.contains("ADVANCED_FACE"));
}
```

**Step 2: Implement smart STEP exporter**

Rewrite `src/step_export.rs`:
- Walk the `SdfNode` DAG to determine export tier
- Tier 1 (exact): write proper BRep STEP entities for recognized primitives:
  - Sphere → `SPHERICAL_SURFACE` with center + radius
  - Box3 → 6 `PLANE` faces, 12 edges, 8 vertices → `CLOSED_SHELL`
  - Cylinder → `CYLINDRICAL_SURFACE` + 2 `PLANE` caps
- Tier 3 (fallback): mesh via adaptive dual contouring, write as tessellated shell
- Entity ID counter tracks the STEP entity numbering

**Step 3: Run tests**

Run: `cargo test step 2>&1`
Expected: All STEP tests PASS

**Step 4: Commit**

```bash
git add -A && git commit -m "feat: smart tiered STEP exporter (exact BRep + tessellated fallback)"
```

---

## Task 11: Wire viewer and existing tests to new mesher

**Files:**
- Modify: `src/bin/viewer.rs` (use Shape builder or new extract_mesh_adaptive)
- Modify: `tests/showcase_test.rs` (ensure all 33 tests pass with new mesher)

**Step 1: Update viewer to use new API**

Update `src/bin/viewer.rs` to either:
(a) Use the Shape builder API: `Shape::sphere(10.0).mesh(settings)`, or
(b) Use `extract_mesh_adaptive` with SdfNode directly

Remove any remaining references to the old `extract_mesh` with resolution parameter.

**Step 2: Update showcase tests**

The old tests use `extract_mesh(sdf, bbox_min, bbox_max, resolution)`.
Either update them to use the new API or ensure the compatibility wrapper still works.

**Step 3: Run all tests**

Run: `cargo test 2>&1`
Expected: ALL tests pass (old showcase + new DAG + new DC + builder + voxel + STEP)

**Step 4: Run viewer**

Run: `cargo run --release --bin viewer`
Expected: Viewer serves at localhost:8080 with all 29 models generated via adaptive DC

**Step 5: Commit**

```bash
git add -A && git commit -m "feat: wire viewer and tests to adaptive mesher"
```

---

## Task 12: Final validation + push

**Step 1: Full test suite**

Run: `cargo test 2>&1`
Expected: ALL tests pass

**Step 2: Clippy + formatting**

Run: `cargo clippy 2>&1`
Fix any warnings.

Run: `cargo fmt --check 2>&1`
Fix any formatting issues.

**Step 3: Verify viewer**

Run: `cargo run --release --bin viewer`
Open http://localhost:8080 and verify:
- Curved shapes are smooth (adaptive resolution)
- Box has sharp edges (QEF)
- All 29 models render
- No shadow artifact

**Step 4: Push to origin**

```bash
git push origin v1.1
```

**Step 5: Update main to mirror v1.1**

```bash
git checkout main
git merge v1.1
git push origin main
```

---

## Dependency graph

```
Task 1 (cleanup) ─┬─► Task 2 (DAG eval) ─► Task 3 (intervals) ─► Task 4 (gradients)
                   │                                                      │
                   │         Task 6 (QEF) ◄───────────────────────────────┘
                   │              │
                   └──► Task 5 (octree) ──► Task 7 (dual contouring) ──► Task 8 (builder)
                                                                              │
                                                    Task 9 (voxel) ◄─────────┤
                                                    Task 10 (STEP) ◄──────────┤
                                                    Task 11 (viewer) ◄────────┘
                                                           │
                                                    Task 12 (validate + push)
```

Critical path: 1 → 2 → 3 → 4 → 5 → 7 → 8 → 11 → 12
Parallelizable: Task 6 (QEF) can be built in parallel with Task 5 (octree)
