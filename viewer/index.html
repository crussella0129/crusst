<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Crusst v1.4 â€” B-Rep Kernel Test</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #08080d; color: #d0d0d0; font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; overflow: hidden; }

  header {
    height: 52px; display: flex; align-items: center; padding: 0 24px;
    background: linear-gradient(135deg, #0e0e16 0%, #151528 100%);
    border-bottom: 1px solid #1e1e30;
  }
  header h1 { font-size: 18px; font-weight: 600; }
  header h1 .accent { color: #ff6b35; }
  header h1 .version { color: #555; font-size: 13px; font-weight: 400; margin-left: 8px; }
  header .spacer { flex: 1; }
  header .badge {
    font-size: 10px; padding: 3px 10px; border-radius: 10px;
    background: #1a3a1a; color: #4caf50; border: 1px solid #2a5a2a;
    letter-spacing: 0.5px; text-transform: uppercase; font-weight: 700;
  }

  .main { display: flex; height: calc(100vh - 52px); }

  .sidebar {
    width: 220px; min-width: 220px; background: #0c0c14;
    border-right: 1px solid #1e1e30; overflow-y: auto;
    display: flex; flex-direction: column;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

  .cat-label {
    font-size: 10px; color: #555; text-transform: uppercase; letter-spacing: 1.5px;
    padding: 14px 16px 6px; font-weight: 700;
  }
  .cat-label:first-child { padding-top: 12px; }

  .shape-btn {
    display: block; width: calc(100% - 16px); margin: 2px 8px; padding: 7px 12px;
    border: 1px solid transparent; border-radius: 6px; background: transparent;
    color: #999; cursor: pointer; font-size: 12px; text-align: left;
    transition: all 0.12s;
  }
  .shape-btn:hover { background: #16162a; color: #ddd; border-color: #2a2a40; }
  .shape-btn.active { background: #1c1c3a; color: #ff6b35; border-color: #ff6b35; font-weight: 600; }

  .viewport { flex: 1; position: relative; }
  .viewport canvas { display: block; }

  #loading {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 13px; color: #444; display: none;
  }
  #loading.show { display: block; }

  .info-panel {
    position: absolute; bottom: 16px; left: 16px;
    background: rgba(8, 8, 13, 0.92); border: 1px solid #1e1e30;
    border-radius: 10px; backdrop-filter: blur(10px); padding: 16px 20px;
    min-width: 280px; font-size: 12px; line-height: 1.8;
  }
  .info-panel h3 { font-size: 15px; color: #ff6b35; margin-bottom: 8px; font-weight: 600; }
  .info-panel .row { display: flex; justify-content: space-between; }
  .info-panel .label { color: #666; }
  .info-panel .value { color: #bbb; font-variant-numeric: tabular-nums; }
  .info-panel .valid { color: #4caf50; font-weight: 700; }
  .info-panel .invalid { color: #f44336; font-weight: 700; }
  .info-panel .divider { border-top: 1px solid #1a1a2a; margin: 8px 0; }
  .info-panel .surfaces { color: #888; font-size: 11px; margin-top: 4px; }
  .info-panel .errors { color: #f44336; font-size: 11px; margin-top: 4px; max-width: 260px; }

  .controls-panel {
    position: absolute; top: 16px; right: 16px;
    background: rgba(8, 8, 13, 0.92); border: 1px solid #1e1e30;
    border-radius: 10px; backdrop-filter: blur(10px); padding: 16px 20px;
    min-width: 200px; font-size: 12px;
  }
  .controls-panel h4 { color: #888; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; }
  .controls-panel .ctrl-row { margin-bottom: 10px; }
  .controls-panel label { display: block; color: #666; font-size: 11px; margin-bottom: 3px; }
  .controls-panel input[type="range"] {
    width: 100%; height: 4px; -webkit-appearance: none; background: #222;
    border-radius: 2px; outline: none;
  }
  .controls-panel input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
    background: #ff6b35; cursor: pointer;
  }
  .controls-panel .val { color: #888; font-size: 10px; text-align: right; }

  .export-bar {
    position: absolute; bottom: 16px; right: 16px;
    display: flex; gap: 6px;
  }
  .export-btn {
    padding: 6px 14px; border: 1px solid #2a2a3e; border-radius: 6px;
    background: #12121e; color: #888; cursor: pointer; font-size: 11px;
    transition: all 0.12s; text-decoration: none;
  }
  .export-btn:hover { background: #1e1e30; color: #fff; border-color: #ff6b35; }
  .export-btn.step { border-color: #2a4a2a; color: #6a6; }
  .export-btn.step:hover { border-color: #4caf50; color: #4caf50; }

  .toggle-row { display: flex; align-items: center; gap: 8px; margin-top: 12px; padding-top: 10px; border-top: 1px solid #1a1a2a; }
  .toggle-row label { color: #666; font-size: 11px; margin: 0; }
  .toggle-row input { accent-color: #ff6b35; }
</style>
</head>
<body>

<header>
  <h1><span class="accent">Crusst</span> B-Rep Kernel<span class="version">v1.4</span></h1>
  <div class="spacer"></div>
  <div class="badge" id="test-badge">Loading...</div>
</header>

<div class="main">
  <div class="sidebar" id="sidebar"></div>
  <div class="viewport" id="viewport">
    <div id="loading" class="show">Initializing...</div>

    <div class="info-panel" id="info-panel">
      <h3 id="shape-name">Select a shape</h3>
      <div id="info-content"></div>
    </div>

    <div class="controls-panel" id="controls-panel">
      <h4>Tessellation</h4>
      <div class="ctrl-row">
        <label>Chord tolerance <span class="val" id="chord-val">0.02</span></label>
        <input type="range" id="chord-slider" min="0.001" max="0.2" step="0.001" value="0.02">
      </div>
      <div class="ctrl-row">
        <label>Min subdivisions <span class="val" id="sub-val">8</span></label>
        <input type="range" id="sub-slider" min="2" max="32" step="1" value="8">
      </div>
      <div class="ctrl-row">
        <label>Max edge length <span class="val" id="edge-val">5.0</span></label>
        <input type="range" id="edge-slider" min="0.5" max="20" step="0.5" value="5.0">
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="wireframe-toggle">
        <label for="wireframe-toggle">Wireframe overlay</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="normals-toggle">
        <label for="normals-toggle">Show normals</label>
      </div>
    </div>

    <div class="export-bar" id="export-bar"></div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let currentShape = null;
let currentMeshGroup = null;
let wireframeOverlay = null;
let normalHelpers = null;
let gallery = [];

const container = document.getElementById('viewport');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x08080d);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.01, 2000);
camera.position.set(30, 25, 30);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.autoRotate = true;
controls.autoRotateSpeed = 1.2;

scene.add(new THREE.AmbientLight(0x303050, 0.5));
const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
keyLight.position.set(25, 35, 20);
scene.add(keyLight);
const fillLight = new THREE.DirectionalLight(0x4488cc, 0.5);
fillLight.position.set(-20, 10, -15);
scene.add(fillLight);
const rimLight = new THREE.DirectionalLight(0xff6b35, 0.3);
rimLight.position.set(0, -15, -25);
scene.add(rimLight);

const grid = new THREE.GridHelper(80, 40, 0x181830, 0x0e0e1a);
grid.position.y = -0.01;
scene.add(grid);

const solidMat = new THREE.MeshPhysicalMaterial({
  color: 0xcc5522, metalness: 0.25, roughness: 0.35,
  clearcoat: 0.4, clearcoatRoughness: 0.15, side: THREE.FrontSide,
});
const wireMat = new THREE.MeshBasicMaterial({
  color: 0xff6b35, wireframe: true, transparent: true, opacity: 0.08,
});
const normalLineMat = new THREE.LineBasicMaterial({ color: 0x44aaff });

function parseBinaryMesh(buffer) {
  const view = new DataView(buffer);
  let offset = 0;
  const nv = view.getUint32(offset, true); offset += 4;
  const positions = new Float32Array(nv * 3);
  for (let i = 0; i < nv * 3; i++) { positions[i] = view.getFloat32(offset, true); offset += 4; }
  const normals = new Float32Array(nv * 3);
  for (let i = 0; i < nv * 3; i++) { normals[i] = view.getFloat32(offset, true); offset += 4; }
  const ni = view.getUint32(offset, true); offset += 4;
  const indices = new Uint32Array(ni);
  for (let i = 0; i < ni; i++) { indices[i] = view.getUint32(offset, true); offset += 4; }
  return { positions, normals, indices, vertexCount: nv, triangleCount: ni / 3 };
}

function clearModel() {
  if (currentMeshGroup) {
    scene.remove(currentMeshGroup);
    currentMeshGroup.traverse(c => { if (c.geometry) c.geometry.dispose(); });
    currentMeshGroup = null;
  }
  if (normalHelpers) { scene.remove(normalHelpers); normalHelpers = null; }
}

function buildNormalHelpers(meshData, scale) {
  const group = new THREE.Group();
  const step = Math.max(1, Math.floor(meshData.vertexCount / 500));
  const pts = [];
  for (let i = 0; i < meshData.vertexCount; i += step) {
    const px = meshData.positions[i*3], py = meshData.positions[i*3+1], pz = meshData.positions[i*3+2];
    const nx = meshData.normals[i*3], ny = meshData.normals[i*3+1], nz = meshData.normals[i*3+2];
    pts.push(px, py, pz, px + nx*scale, py + ny*scale, pz + nz*scale);
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
  group.add(new THREE.LineSegments(geo, normalLineMat));
  return group;
}

function makeInfoRow(labelText, valueText, valueClass) {
  const row = document.createElement('div');
  row.className = 'row';
  const lbl = document.createElement('span');
  lbl.className = 'label';
  lbl.textContent = labelText;
  const val = document.createElement('span');
  val.className = valueClass || 'value';
  val.textContent = valueText;
  row.appendChild(lbl);
  row.appendChild(val);
  return row;
}

function makeDivider() {
  const d = document.createElement('div');
  d.className = 'divider';
  return d;
}

async function loadShape(name) {
  currentShape = name;
  const loadingEl = document.getElementById('loading');
  loadingEl.classList.add('show');

  const chord = document.getElementById('chord-slider').value;
  const sub = document.getElementById('sub-slider').value;
  const edge = document.getElementById('edge-slider').value;
  const qs = 'chord=' + chord + '&minsub=' + sub + '&maxedge=' + edge;

  const [meshRes, infoRes] = await Promise.all([
    fetch('/api/mesh/' + name + '?' + qs),
    fetch('/api/info/' + name + '?' + qs),
  ]);

  if (!meshRes.ok) { loadingEl.textContent = 'Shape not found'; return; }

  const meshBuf = await meshRes.arrayBuffer();
  const info = await infoRes.json();
  const meshData = parseBinaryMesh(meshBuf);

  clearModel();

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(meshData.positions, 3));
  geo.setAttribute('normal', new THREE.BufferAttribute(meshData.normals, 3));
  geo.setIndex(new THREE.BufferAttribute(meshData.indices, 1));

  const group = new THREE.Group();
  group.add(new THREE.Mesh(geo, solidMat));

  wireframeOverlay = new THREE.Mesh(geo.clone(), wireMat);
  wireframeOverlay.visible = document.getElementById('wireframe-toggle').checked;
  group.add(wireframeOverlay);

  const bbox = new THREE.Box3().setFromBufferAttribute(geo.attributes.position);
  const center = new THREE.Vector3();
  bbox.getCenter(center);
  group.position.sub(center);

  const size = new THREE.Vector3();
  bbox.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z);
  const dist = maxDim * 1.8;
  camera.position.set(dist * 0.7, dist * 0.5, dist * 0.7);
  controls.target.set(0, 0, 0);
  controls.update();
  grid.position.y = bbox.min.y - center.y - 0.5;

  scene.add(group);
  currentMeshGroup = group;

  const normalScale = maxDim * 0.04;
  normalHelpers = buildNormalHelpers(meshData, normalScale);
  normalHelpers.position.copy(group.position);
  normalHelpers.visible = document.getElementById('normals-toggle').checked;
  scene.add(normalHelpers);

  // Update info panel using safe DOM methods
  const displayName = name.replace(/_/g, ' ');
  document.getElementById('shape-name').textContent = displayName.charAt(0).toUpperCase() + displayName.slice(1);

  const content = document.getElementById('info-content');
  while (content.firstChild) content.removeChild(content.firstChild);

  content.appendChild(makeInfoRow('B-Rep Vertices', String(info.vertices)));
  content.appendChild(makeInfoRow('B-Rep Edges', String(info.edges)));
  content.appendChild(makeInfoRow('B-Rep Faces', String(info.faces)));
  content.appendChild(makeInfoRow('Euler (V-E+F)', String(info.euler)));
  content.appendChild(makeDivider());
  content.appendChild(makeInfoRow('Mesh Vertices', meshData.vertexCount.toLocaleString()));
  content.appendChild(makeInfoRow('Mesh Triangles', meshData.triangleCount.toLocaleString()));
  content.appendChild(makeInfoRow('Bounding Box', size.x.toFixed(1) + ' x ' + size.y.toFixed(1) + ' x ' + size.z.toFixed(1)));
  content.appendChild(makeDivider());
  content.appendChild(makeInfoRow('Topology', info.valid ? 'VALID SOLID' : 'INVALID', info.valid ? 'valid' : 'invalid'));

  const surfDiv = document.createElement('div');
  surfDiv.className = 'surfaces';
  surfDiv.textContent = 'Surfaces: ' + info.surfaces.join(', ');
  content.appendChild(surfDiv);

  if (info.errors && info.errors.length > 0) {
    const errDiv = document.createElement('div');
    errDiv.className = 'errors';
    errDiv.textContent = info.errors.join('; ');
    content.appendChild(errDiv);
  }

  // Update export buttons
  const bar = document.getElementById('export-bar');
  while (bar.firstChild) bar.removeChild(bar.firstChild);
  [
    { fmt: 'step', label: 'STEP', cls: 'step', tip: 'Exact B-Rep geometry' },
    { fmt: 'stl',  label: 'STL',  cls: '',     tip: 'Binary triangle mesh' },
    { fmt: 'obj',  label: 'OBJ',  cls: '',     tip: 'Wavefront with normals' },
    { fmt: '3mf',  label: '3MF',  cls: '',     tip: '3D Manufacturing Format' },
  ].forEach(function(e) {
    const a = document.createElement('a');
    a.className = 'export-btn ' + e.cls;
    a.textContent = e.label;
    a.title = e.tip;
    a.href = '/api/export/' + e.fmt + '/' + name + '?' + qs;
    a.download = '';
    bar.appendChild(a);
  });

  // Highlight sidebar button
  document.querySelectorAll('.shape-btn').forEach(function(b) { b.classList.remove('active'); });
  const activeBtn = document.querySelector('.shape-btn[data-name="' + name + '"]');
  if (activeBtn) activeBtn.classList.add('active');

  loadingEl.classList.remove('show');
}

async function buildSidebar() {
  const res = await fetch('/api/gallery');
  gallery = await res.json();
  const sidebar = document.getElementById('sidebar');
  let lastCat = '';
  gallery.forEach(function(m) {
    if (m.category !== lastCat) {
      const label = document.createElement('div');
      label.className = 'cat-label';
      label.textContent = m.category;
      sidebar.appendChild(label);
      lastCat = m.category;
    }
    const btn = document.createElement('button');
    btn.className = 'shape-btn';
    btn.textContent = m.label;
    btn.dataset.name = m.name;
    btn.addEventListener('click', function() { loadShape(m.name); });
    sidebar.appendChild(btn);
  });
  document.getElementById('test-badge').textContent = gallery.length + ' shapes';
}

function setupControls() {
  const chordSlider = document.getElementById('chord-slider');
  const subSlider = document.getElementById('sub-slider');
  const edgeSlider = document.getElementById('edge-slider');
  let debounceTimer;
  function onSettingsChange() {
    document.getElementById('chord-val').textContent = parseFloat(chordSlider.value).toFixed(3);
    document.getElementById('sub-val').textContent = subSlider.value;
    document.getElementById('edge-val').textContent = parseFloat(edgeSlider.value).toFixed(1);
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(function() {
      if (currentShape) loadShape(currentShape);
    }, 300);
  }
  chordSlider.addEventListener('input', onSettingsChange);
  subSlider.addEventListener('input', onSettingsChange);
  edgeSlider.addEventListener('input', onSettingsChange);
  document.getElementById('wireframe-toggle').addEventListener('change', function(e) {
    if (wireframeOverlay) wireframeOverlay.visible = e.target.checked;
  });
  document.getElementById('normals-toggle').addEventListener('change', function(e) {
    if (normalHelpers) normalHelpers.visible = e.target.checked;
  });
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

window.addEventListener('resize', function() {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

async function init() {
  await buildSidebar();
  setupControls();
  animate();
  if (gallery.length > 0) loadShape(gallery[0].name);
}
init();
</script>
</body>
</html>
